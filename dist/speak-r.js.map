{"version":3,"file":null,"sources":["../app/lang/syntax.js","../app/token.js","../app/ramda-piped.js","../app/util.js","../app/fabric.js","../app/splitter.js","../app/string-preprocess.js","../app/lexeme.js","../app/head-list.js","../app/lang/tooling.js","../app/tree.js","../app/convolve.js","../app/say.js","../app/index.js"],"sourcesContent":["const op = {\r\n  doubledots:'::',\r\n  comma:',',\r\n  dash:'_',\r\n  arrow:'->',\r\n  doublearrow:'=>',\r\n  middlepipe:'<|>',\r\n  backpipe:'<|',\r\n  forwardpipe: '|>',\r\n  equals:'==',\r\n  plus:'+',\r\n  minus:'-',\r\n  map:'^'\r\n}\r\nconst types = {\r\n  type:'type',\r\n  R:'R',\r\n  string:'string',\r\n  number:'number',\r\n  op:'operator',\r\n  any:'any',\r\n  context:'context',\r\n  lex:'lexeme'\r\n}\r\nconst jstypes = [\r\n  ['Array', Array],\r\n  ['Number', Number],\r\n  ['String', String],\r\n  ['Function', Function],\r\n  ['Object', Object],\r\n  ['Null', null],\r\n  ['RegExp', RegExp]]\r\nconst quotes = ['\"',\"'\",'`']\r\nconst categories = {\r\n  piped:[types.R,types.context,types.lex],\r\n  inserted:[types.number,types.string,types.type,types.any],\r\n  control:[types.op]\r\n}\r\nconst lexemeTypes = {\r\n  pipe:'Pipe',\r\n  context:'Context',\r\n  atomic:'AtomicFunc',\r\n  expr:'Expression'\r\n}\r\nmodule.exports = {op,types,quotes,categories,jstypes,lexemeTypes}","const R = require('ramda')\r\n\r\n/*class Token {\r\n  constructor(type,value) {\r\n    this.type = type\r\n    this.value = value\r\n  }\r\n  // toString(){return `type ${this.type}\\nvalue ${this.value}`+this.index?`${this.index}`:''}\r\n}*/\r\n\r\nconst TokenFabric = R.curry((category,obj)=>{\r\n  return /*new Token(category,obj)*/{\r\n    type:category,\r\n    value:obj\r\n  }\r\n})\r\n\r\nmodule.exports = {\r\n  Type:     TokenFabric('type'),\r\n  R:        TokenFabric('R'),\r\n  String:   TokenFabric('string'),\r\n  Number:   TokenFabric('number'),\r\n  Operator: TokenFabric('operator'),\r\n  Any:      TokenFabric('any'),\r\n  Context:  TokenFabric('context')\r\n}","const R = require('ramda')\r\n\r\nconst def = (func,obj)=>prop=>\r\n  Object.defineProperty(obj,prop[0],{\r\n    get:function(){\r\n      func(prop[1])\r\n      return obj}})\r\nconst appender = _store=>val=>_store.push(val)\r\nconst inputCheck = (argsArr,_store)=>!R.isEmpty(argsArr)&&!R.is(Function,argsArr[0])&&R.none(R.isNil,argsArr)&&!R.isEmpty(_store)\r\nconst setter = (store,ins,dict)=> R.pipe(R.toPairs,R.forEach(def(appender(store),ins)))(dict)\r\nfunction polymorph(store) {\r\n  return function ins(...val) {\r\n    if (inputCheck(val,store)) {\r\n      store.push(R.apply(store.pop())(val))\r\n    }\r\n    return ins\r\n  }\r\n}\r\nfunction storage(dict) {\r\n  var store = []\r\n  var ins = polymorph(store)\r\n  ins.exec = function() {return R.apply(R.pipe, store)}\r\n  ins.toString = function(){return ''}\r\n  Object.defineProperty(ins,'store',{get:function(){return store}})\r\n  Object.defineProperty(ins,'exec',{get: function() {return R.apply(R.pipe, store)}})\r\n  setter(store,ins,dict)\r\n  return ins\r\n}\r\nconst RP = {}\r\nObject.defineProperty(RP,'do',{get:function(){return storage(R)}})\r\n\r\nmodule.exports = RP","const R = require('ramda')\r\nconst debug = require('debug')\r\n\r\nconst RP = require('./ramda-piped')\r\n\r\nconst tagvalue = (tag,mess)=>R.isNil(mess) ? tag : [tag,mess].join(':  ')\r\nconst log = tag=>mess=>debug(tagvalue(tag,mess))\r\nconst pipelog = tag=>mess=>R.tap(log(tag)(mess))\r\n\r\nconst toPipe = R.apply(R.pipe)\r\n\r\nconst pRed = (acc,val)=>R.ifElse(R.is(Array),R.concat(acc),R.append(R.__,acc))(val)\r\nconst P = (...pipes)=>toPipe(R.reduce(pRed,[],pipes))\r\n\r\nconst arrayify = R.unless(R.is(Array),R.of)\r\nconst isContainOrEq = P(arrayify,R.flip(R.contains))\r\n\r\nconst isString = R.is(String)\r\n\r\n\r\nconst {create, env} = require('sanctuary');\r\n\r\nconst checkTypes = false//process.env.NODE_ENV !== 'production';\r\nconst S = create({checkTypes: checkTypes, env: env})\r\n\r\nconst prop = {\r\n  type:R.prop('type'),\r\n  val:R.prop('value'),\r\n  head:R.prop('head'),\r\n  tail:R.prop('tail')\r\n}\r\nmodule.exports = {\r\n  pipelog,log,isString,arrayify,toPipe,P,isContainOrEq,prop,RP,S\r\n}","const R = require('ramda')\r\nconst syntax = require('./lang/syntax')\r\n\r\n\r\nconst Token = require('./token.js')\r\nconst util = require('./util')\r\nconst S = util.S\r\n\r\nconst isString = util.isString\r\n// const log = util.log('fabric')\r\n// const pipelog = util.pipelog('fabric')\r\n\r\nconst TokenFabric = (tokenType, condition, transformation) => {\r\n  const onCondition = R.pipe(util.arrayify, R.allPass, S.either(R.__, R.F))\r\n  const addSteps = R.flip(R.concat)([tokenType, S.Right])\r\n  const transformUntouched = R.pipe(\r\n    R.defaultTo([]),\r\n    util.arrayify,\r\n    addSteps,\r\n    util.toPipe,\r\n    S.either(R.__, R.identity))\r\n  return R.when(onCondition(condition), transformUntouched(transformation))\r\n}\r\n\r\nconst quoteProcessor = function () {\r\n  const isQuote = R.anyPass(R.map(R.equals, syntax.quotes))\r\n  const isQuoted = R.allPass(R.map(e => R.pipe(e, isQuote), [R.head, R.last]))\r\n  const removeQuotes = R.pipe(R.init, R.tail)\r\n  return TokenFabric(Token.String, [isString, isQuoted], [R.trim, removeQuotes])\r\n}\r\nconst typesProcessor = () => {\r\n  const types = new Map(syntax.jstypes)\r\n  const isInMap = obj => isString(obj) ? types.has(obj) : false\r\n  return TokenFabric(Token.Type, isInMap, e => types.get(e))\r\n}\r\n\r\nconst isNumber = TokenFabric(Token.Number, isFinite, parseFloat)\r\nconst vendorProcessor = () => {\r\n  const isFunc = R.is(Function)\r\n  const isRamda = obj => isFunc(R[obj])\r\n  return TokenFabric(Token.R, [isString, isRamda], R.prop(R.__, R))\r\n}\r\nconst contextValidation = str => R.pipe(R.match(/\\D\\w+/), R.head, R.equals(str))(str)\r\nconst isContext = TokenFabric(Token.Context, contextValidation)\r\n\r\nconst preprocess = S.lift(R.when(isString, R.trim))\r\nconst postprocess = R.identity\r\nmodule.exports = {\r\n  isQuote: quoteProcessor(),\r\n  isType: typesProcessor(),\r\n  isVendor: vendorProcessor(),\r\n  isNumber,\r\n  isContext,\r\n  preprocess,\r\n  postprocess\r\n}","const R = require('ramda')\r\nconst util = require('./util')\r\n// const S = require('sanctuary')\r\n\r\nconst Token = require('./token.js')\r\nconst log = util.pipelog('splitter')\r\nconst operators = R.values(require('./lang/syntax').op) //TODO rewrite op list using\r\n\r\nconst toPipe = util.toPipe\r\nconst stringMorpher = morph=>R.map(R.when(util.isString,morph))\r\nconst stringTrim = stringMorpher(R.trim)\r\nconst rejectEmpty = R.reject(R.isEmpty)\r\n\r\nconst opersFuncs = [\r\n  R.split,\r\n  R.pipe(Token.Operator,R.intersperse)\r\n]\r\nconst constFuncs = [\r\n  rejectEmpty,\r\n  R.unnest\r\n]\r\n\r\nconst splitCond = symb=>R.cond([\r\n  [R.is(String),symb],\r\n  [R.T,log('uncaught')]\r\n])\r\nconst unnester = symbPipe=>R.pipe(\r\n  symbPipe,\r\n  R.unnest)\r\nconst splitsPipe = [\r\n  R.of,\r\n  R.ap(opersFuncs),\r\n  R.concat(R.__,constFuncs),\r\n  toPipe,\r\n  splitCond,\r\n  R.map,\r\n  unnester,\r\n  log('splitPipe')]\r\nconst splitter = R.pipe(toPipe,R.map(R.__,operators),toPipe)(splitsPipe)\r\nconst cleaner = R.pipe(R.unnest,stringTrim,rejectEmpty,log('end'))\r\nconst execFuncs = [\r\n  util.arrayify,\r\n  splitter,\r\n  cleaner]\r\nconst exec = toPipe(execFuncs)\r\nmodule.exports = {exec,cleaner}","const R = require('ramda')\r\n\r\nconst fab = require('./fabric.js')\r\n\r\nconst splitter = require('./splitter.js')\r\n\r\nconst util = require('./util')\r\nconst S = util.S\r\n\r\nconst pipelog = util.pipelog('preproc')\r\nconst singleWordParsing =\r\n  R.pipe(\r\n    fab.preprocess,\r\n    pipelog('->isQuote'),\r\n    fab.isQuote,\r\n    pipelog('->isNumber'),\r\n    fab.isNumber,\r\n    pipelog('->isType'),\r\n    fab.isType,\r\n    pipelog('->isVendor'),\r\n    fab.isVendor,\r\n    pipelog('->isContext'),\r\n    fab.isContext,\r\n    pipelog('->postprocess'),\r\n    fab.postprocess)\r\nconst splitKeywords=\r\n  R.unary(R.pipe(\r\n    R.unless(util.isString, () => { throw new Error('`keywords` should be String'); }),\r\n\r\n    R.split(' '),\r\n\r\n    R.reject(R.isEmpty),\r\n    splitter.exec,\r\n    R.map(R.ifElse(R.is(Object),S.Right,S.Left)),\r\n    pipelog('тэг'),\r\n\r\n    R.map(singleWordParsing),\r\n    R.dropRepeatsWith((a,b)=>R.allPass([\r\n      R.propEq('type','operator'),\r\n      R.propEq('obj',','),\r\n      R.eqProps('obj',R.__,b)\r\n    ])(a))\r\n  ))\r\n\r\n\r\nmodule.exports = splitKeywords","const R = require('ramda')\r\n\r\nconst lexemeTypes = require('./lang/syntax').lexemeTypes\r\n\r\nclass ILexeme {\r\n  constructor(typename,obj) {\r\n    obj.index = obj.head.index\r\n    obj.lexeme = typename\r\n    return obj\r\n  }\r\n}\r\nclass Lexeme {\r\n  static Pipe(tokensHList) {\r\n    return new ILexeme(lexemeTypes.pipe,tokensHList)\r\n  }\r\n  static AtomicFunc(tokensHList) {\r\n    return new ILexeme(lexemeTypes.atomic,tokensHList)\r\n  }\r\n  static Expression(tokensHList) {\r\n    return new ILexeme(lexemeTypes.expr,tokensHList)\r\n  }\r\n  static get its() {\r\n    const eq = R.propEq('lexeme')\r\n    return R.map(eq,lexemeTypes)\r\n  }\r\n  static Context(token) {\r\n    return new Lexeme(lexemeTypes.context,token)\r\n  }\r\n}\r\n\r\nmodule.exports = Lexeme","const R = require('ramda')\r\n\r\nconst util = require('./util')\r\nconst S = util.S\r\n\r\nconst P = util.P\r\n\r\nclass HeadList {\r\n  constructor(rawList, head) {\r\n    if (!R.is(Array,rawList)||R.isEmpty(rawList)) return S.Left('No array recieved')\r\n    if (R.isNil(head)) {\r\n      this.head = R.head(rawList)\r\n      this.tail = R.tail(rawList)\r\n    } else {\r\n      this.head = head\r\n      this.tail = rawList||[]\r\n    }\r\n  }\r\n  map(func) {\r\n    return R.map(func,this.toArray)\r\n  }\r\n  get toArray() {\r\n    return R.prepend(this.head,this.tail)\r\n  }\r\n  get length() {\r\n    return R.defaultTo(0,this.tail.length)+R.isEmpty(this.head)?0:1\r\n  }\r\n  append(e) {\r\n    if (R.isEmpty(this.tail)&&R.isEmpty(this.head))\r\n      this.head = e\r\n    else\r\n      this.tail.push(e)\r\n    return this\r\n  }\r\n\r\n  static hasTail(list) {return R.has('tail',list)&&!R.isEmpty(list.tail)}\r\n  static last(list) {\r\n    return HeadList.hasTail(list)\r\n      ? R.last(list.tail)\r\n      : list.head\r\n  }\r\n  static lastR(list,isStrict=false) {\r\n    const _hasTail = R.has('tail')\r\n    const notHas = P(_hasTail,R.not)\r\n    const cond = R.either(notHas,P(HeadList.last,notHas))\r\n    return R.until(isStrict?cond:notHas,HeadList.last)(list)\r\n  }\r\n  static emptyList() {\r\n    return new HeadList([{}])\r\n  }\r\n  static isList(list) {\r\n    return R.has('head',list)\r\n  }\r\n}\r\n\r\nmodule.exports = HeadList","const R = require('ramda')\r\n\r\nconst util = require('../util')\r\nconst P = util.P\r\n\r\nconst syntax = require('./syntax')\r\nconst types = syntax.types\r\nconst op = syntax.op\r\n\r\nconst multiCheck = func=>R.map(e=>P(util.arrayify,P(func,R.map)(e),R.anyPass))\r\n\r\nconst checkToken = type=>val=>R.whereEq({type:type,value:val})\r\nconst checkOper = checkToken(types.op)\r\nconst checkType = R.propEq('type')\r\n\r\nconst def = (func,obj)=>prop=>\r\n  Object.defineProperty(obj,prop[0],{\r\n    get:function(){\r\n      func(prop[1])\r\n      return obj}})\r\nfunction polymorph(store) {\r\n  return function ins(val) {\r\n    return R.ifElse(R.either(R.isNil,()=>R.isEmpty(store)),()=>ins, R.anyPass(store))(val)\r\n  }\r\n}\r\nconst appender = store=>val=>store.push(val)\r\nconst setter = (store,ins,dict)=>P(\r\n  R.toPairs,\r\n  R.forEach(\r\n    def(appender(store),ins)))(dict)\r\nfunction storage(dict) {\r\n  var store = []\r\n  var ins = polymorph(store)\r\n  Object.defineProperty(ins,'store',{get:function(){return store}})\r\n  setter(store,ins,dict)\r\n  return ins\r\n}\r\n\r\nconst eq = {\r\n  op:       R.map( checkOper )(op),\r\n  type:     R.map( checkType )(types),\r\n  typedVal: R.map( checkToken )(types)\r\n}\r\n\r\nconst equals = {}\r\nObject.defineProperty(equals,'op',{get:function(){return storage(eq.op)}})\r\nObject.defineProperty(equals,'type',{get:function(){return storage(eq.type)}})\r\nObject.defineProperty(equals,'typedVal',{get:function(){return storage(eq.typedVal)}})\r\n\r\n\r\n\r\nmodule.exports = {eq,equals}","const R = require('ramda')\r\n\r\nconst util = require('./util')\r\nconst S = util.S\r\n\r\nconst P = util.P\r\nconst RP = util.RP\r\n// const log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\nconst prop = util.prop\r\n\r\nconst Lexeme = require('./lexeme.js')\r\nconst HeadList = require('./head-list.js')\r\n\r\nconst types = require('./lang/syntax').types\r\nconst tool = require('./lang/tooling')\r\nconst eq = tool.equals\r\n// const example = \"tokens :: Array prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n// const exampleNoDef = \"prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n//const onChecking = P(  R.prepend(  R.take(2) , R.equals('|>') ) , R.apply(R.ifElse) )\r\n//const __tranducer = P(R.ifElse(P(R.prop('value'),R.propEq('type','R')),P(R.prop('value'),R.of,R.append)),R.map)\r\n// const exampleTrans = \"ifElse <| prop 'value' propEq 'type' 'R' <|> prop 'value' of append |> map\" // _ identity\r\n\r\n// const isTokenCat = tokenArray=>P(prop.type,util.isContainOrEq(tokenArray))\r\n\r\n\r\n// const filterM = func=>e=>e.filter(func)\r\n// const filterMs = func=>P(R.map(filterM(func)),S.justs)\r\n// const indexOf = e => e.isJust ? e.value.index : NaN\r\n// const rangeMs = (min,max)=>R.map(R.reject(e=>indexOf(R.either(R.gt(max),R.lt(min)))))\r\n\r\n//TODO make isSymbol and other work through R.whereEq\r\n// const isSymbol = tokenPred => R.allPass([isOperator, propEqVal(tokenPred)])\r\n// const eq.op = R.map(isSymbol,op)\r\n\r\nfunction stringTokenTransform(data) {\r\n  const indexPipe = (e,i)=>S.lift(R.assoc('index',i))(e)\r\n  const indexation = list=>list.map(indexPipe)\r\n  return P(R.map(S.eitherToMaybe),indexation)(data)\r\n}\r\n\r\n// function stageHeader(data) {\r\n//   const errorFabric = text=>()=>S.Left(text)\r\n//   const err = R.map(errorFabric,{\r\n//     nothing:'Nothing finded',\r\n//     many:'Find more than one ::',\r\n//     other:'Undefined error'\r\n//   })\r\n//   const findDD = filterMs(eq.op.doubledots)\r\n//   const split = P(R.head,R.prop('index'),R.splitAt(R.__,data),S.Right)\r\n//   const indexChanger = RP.do.lensIndex.over.exec\r\n//   const over = {\r\n//     head:indexChanger(0),\r\n//     body:indexChanger(1)\r\n//   }\r\n//   const headChange = P(filterMs(isTokenCat(types.context)),R.map(P(Lexeme.Context,S.Maybe.of)))\r\n//   const headContextMounter = S.either(S.Left,P(over.head(headChange),over.body(R.tail),S.Right))\r\n//   const cond = R.cond([\r\n//     [R.isEmpty,err.nothing],\r\n//     [e=>R.gt(R.length(e),1),err.many],\r\n//     [e=>R.equals(R.length(e),1),split],\r\n//     [R.T,err.other]\r\n//   ])\r\n\r\n//   return P(findDD,cond,headContextMounter)(data)\r\n// }\r\nfunction detectContext(data) {\r\n  // const filt = filterMs(eq.op.doubledots())//x=>R.whereEq({value:\"data\"},x))\r\n  // let dd = P(filt,RP.do.head.indexOf(R.__,data).splitAt(R.__,data).adjust(R.tail,1).exec)(data)\r\n  return data\r\n}\r\nfunction headSplitter(isMaster,onMaster,changeLast) {\r\n  const lensLast = RP.do.length.dec.lensIndex.exec\r\n  const onEmpty = e=>R.append(Lexeme.Pipe(new HeadList([e])))\r\n  const onSlave = e=>list=>R.ifElse(R.isEmpty,\r\n    onEmpty(e),\r\n    R.over(lensLast(list),changeLast(e)))(list)\r\n  const tranducer = R.map(R.ifElse(isMaster,onMaster,onSlave))\r\n  return R.transduce(tranducer,(acc,val)=>val(acc))\r\n}\r\nfunction intoAtomics(data) {\r\n  const changeLast = e=>P(util.arrayify,R.append(e.value))\r\n  const isMaster = P(prop.val,eq.type.R.op.context)\r\n  const onMaster = P(prop.val,R.of,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\nfunction intoPipes(data) {\r\n  const changeLast = e=>hList=>hList.append(e)\r\n  const pipeSymbols = eq.op.forwardpipe.middlepipe.backpipe\r\n  const isMaster = R.both(HeadList.isList,P(prop.head, pipeSymbols))\r\n  const onMaster = P(R.identity,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\n\r\nfunction checkReplace(data) {\r\n  const replacers = [\r\n    [eq.op.dash,types.any,R.__],\r\n    [eq.op.equals,types.R,R.equals],\r\n    [eq.op.plus,types.R,R.add],\r\n    [eq.op.minus,types.R,R.subtract],\r\n    [eq.op.map,types.R,R.map]\r\n  ]\r\n\r\n  const replacer = (type,value)=>e=>{\r\n    e.value = value\r\n    e.type = type\r\n    return e\r\n  }\r\n  const doCheckReplace = (checker,type,value)=>R.map(R.when(checker,replacer(type,value)))\r\n  const reducer = (acc,val)=>R.apply(doCheckReplace,val)(acc)\r\n  const doReplaceAll = rules=>data=>R.reduce(reducer,data,rules)\r\n  const replAll = doReplaceAll(replacers)\r\n  return replAll(data)\r\n}\r\n\r\nfunction lexemize(data) {\r\n  const detectAtomic = R.when(P(prop.head,eq.type.R),Lexeme.AtomicFunc)\r\n  const detectExpr   = R.when(P(prop.head,eq.type.op),Lexeme.Expression)\r\n  const detecting = P(e=>new HeadList(e),detectAtomic,detectExpr)\r\n  const lexemizing = P(S.lift(checkReplace),intoAtomics,R.map(detecting))\r\n  return lexemizing(data)\r\n}\r\n\r\nfunction getSyntaxTree(data) {\r\n  return P(stringTokenTransform,detectContext,pipelog('lexemize<-'),lexemize,pipelog('intoPipes'),intoPipes)(data)\r\n}\r\n\r\nmodule.exports = getSyntaxTree","const R = require('ramda')\r\n\r\nconst util = require('./util')\r\nconst S = util.S\r\n\r\nconst P = util.P\r\nconst log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\n\r\nconst tool = require('./lang/tooling')\r\n\r\n\r\nconst eqOp = tool.eq.op\r\nconst stateNames = ['pipe','open','mid','close']\r\nconst states = {\r\n  empty:0,\r\n  pipe:1,\r\n  open:2,\r\n  mid:3,\r\n  close:4\r\n}\r\nconst actions = {\r\n  next:0,\r\n  child:1,\r\n  parent:-1,\r\n  error:NaN\r\n}\r\nconst opCond = opVal => R.both(Lexeme.its.expr, P(util.prop.head,opVal))\r\nconst stateConds = {\r\n  pipe:Lexeme.its.pipe,\r\n  open:opCond(eqOp.backpipe),\r\n  mid:opCond(eqOp.middlepipe),\r\n  close:opCond(eqOp.forwardpipe)\r\n}\r\nconst stConds = R.cond(R.append([R.T,states.pipe],R.map(e=>[stateConds[e],()=>states[e]],stateNames)))\r\n\r\nconst switches = [\r\n  [NaN,1,1,NaN,1], // empty\r\n  [NaN,0,1,NaN,0], // pipe\r\n  [NaN,-1,1,0,-1], // open\r\n  [NaN,-1,1,0,-1], // mid\r\n  [NaN,0,1,NaN,0]  // close\r\n]\r\nfunction optimise(data) {\r\n  const exprToPipe = R.when(Lexeme.its.expr,P(util.prop.tail,e=>new HeadList(e), Lexeme.Pipe))\r\n  const singlePipeToAtomic = R.when(R.both(Lexeme.its.pipe,P(HeadList.hasTail,R.not)),util.prop.head)\r\n  return P(exprToPipe,singlePipeToAtomic)(data)\r\n}\r\nconst appendTo = obj=>e=>obj.append(e)\r\nfunction Stack() {\r\n  this.value = []\r\n  this.push = obj=>this.value.push(appendTo(obj))\r\n  this.pushLast = result=>this.push(HeadList.lastR(result,true))\r\n  this.pop = ()=>this.value.pop()\r\n  this.addToLast = val=>R.last(this.value)(val)\r\n}\r\nfunction convolve(data) {\r\n  if (!R.is(Array,data)) return S.Left('No array recieved')\r\n  var result = HeadList.emptyList()\r\n  let stack = new Stack()\r\n  let state = states.empty\r\n  let i = 0\r\n  while(i<data.length) {\r\n    var e = data[i]\r\n    let nextState = stConds(e)\r\n    let doAction = switches[state][nextState]\r\n    switch(doAction) {\r\n      case actions.child:\r\n        stack.pushLast(result)\r\n        break\r\n      case actions.parent:\r\n        stack.pop()\r\n        break\r\n    }\r\n    state = nextState\r\n    stack.addToLast(optimise(e))\r\n    i++\r\n  }\r\n  return P(Lexeme.Pipe,optimise)(result)\r\n}\r\n\r\nmodule.exports = convolve","const R = require('ramda')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\nconst util = require('./util')\r\nconst P = util.P\r\n\r\nfunction CompileException(obj) {\r\n  this.message = `Can not compile object ${obj}`\r\n  this.name = \"Compile exeption\"\r\n}\r\n\r\nfunction collectData(obj) {\r\n  const collect = R.cond([\r\n    [R.is(Array),sayPipe],\r\n    [P(HeadList.isList,R.not),util.prop.val],\r\n    [Lexeme.its.pipe,sayPipe],\r\n    [Lexeme.its.atomic,sayAtomic],\r\n    [R.T,e=>{throw new CompileException(e)}]\r\n  ])\r\n  return collect(obj)\r\n}\r\n\r\nfunction sayPipe(list) {\r\n  const normalize = R.when(HeadList.isList,R.prop('toArray'))\r\n  return P(normalize,R.map(collectData),R.apply(R.pipe))(list)\r\n}\r\n\r\nfunction sayAtomic(list) {\r\n  return HeadList.hasTail(list)\r\n    ? R.apply(collectData(list.head),R.map(collectData,list.tail))\r\n    : collectData(list.head)\r\n}\r\n\r\nfunction say(data) {\r\n  return collectData(data)\r\n}\r\n\r\nmodule.exports = say","// const R = require('ramda')\r\n// const S = require('sanctuary')\r\n\r\nconst preproc = require('./string-preprocess')\r\nconst getTree = require('./tree')\r\nconst convolve = require('./convolve')\r\n\r\nconst util = require('./util')\r\nconst P = util.P\r\nconst log = util.log('index')\r\n// const pipelog = util.pipelog('index')\r\n// const Print = require('./print.js')\r\nconst Say = require('./say.js')\r\n\r\nfunction say(data) {\r\n  return P(preproc,getTree,convolve,/*R.tap(e=>Print.headList('conv',e,-1)),*/ Say)(data)\r\n}\r\n\r\nconst pureExample = \"data sright :: head prop 'index' splitAt _ @data sright\"\r\nconst simple = \"when <| == 1 not <|> + 10 |> + 100\"\r\n// const pure = P( R.when(P(R.equals(1),R.not),R.add(10)),R.add(100))\r\n\r\n// let convolved = say(pureExample)\r\nlog('example')(pureExample)\r\n\r\n// Print.headList('conv',convolved,-1)\r\nlet word = say(simple)\r\n// let res = word(1)\r\n// log('word')(res)\r\n\r\nmodule.exports = say"],"names":["const","op","doubledots","comma","dash","arrow","doublearrow","middlepipe","backpipe","forwardpipe","equals","plus","minus","map","types","type","R","string","number","any","context","lex","jstypes","Array","Number","String","Function","Object","RegExp","quotes","categories","piped","inserted","control","lexemeTypes","pipe","atomic","expr","module","exports","require$$0","TokenFabric","curry","category","obj","value","Type","Operator","Any","Context","polymorph","store","ins","inputCheck","val","push","apply","pop","storage","dict","exec","toString","defineProperty","get","setter","def","func","prop","appender","_store","argsArr","isEmpty","is","none","isNil","toPairs","forEach","RP","require$$3","debug","require$$2","require$$1","tagvalue","tag","mess","join","log","pipelog","tap","toPipe","pRed","acc","ifElse","concat","append","__","P","reduce","pipes","arrayify","unless","of","isContainOrEq","flip","contains","isString","create","env","checkTypes","S","head","tail","syntax","Token","util","tokenType","condition","transformation","onCondition","allPass","either","F","addSteps","Right","transformUntouched","defaultTo","identity","when","quoteProcessor","isQuote","anyPass","isQuoted","e","last","removeQuotes","init","trim","typesProcessor","Map","isInMap","has","isNumber","isFinite","parseFloat","vendorProcessor","isFunc","isRamda","contextValidation","str","match","isContext","preprocess","lift","postprocess","isType","isVendor","operators","values","stringMorpher","morph","stringTrim","rejectEmpty","reject","opersFuncs","split","intersperse","constFuncs","unnest","splitCond","symb","cond","T","unnester","symbPipe","splitsPipe","ap","splitter","cleaner","execFuncs","fab","singleWordParsing","splitKeywords","unary","Error","Left","dropRepeatsWith","a","b","propEq","eqProps","ILexeme","typename","index","lexeme","Lexeme","Pipe","tokensHList","AtomicFunc","Expression","its","eq","token","HeadList","rawList","this","toArray","prepend","length","hasTail","list","lastR","isStrict","_hasTail","notHas","not","until","emptyList","isList","checkToken","whereEq","checkOper","checkType","typedVal","stringTokenTransform","data","indexPipe","i","assoc","indexation","eitherToMaybe","detectContext","headSplitter","isMaster","onMaster","changeLast","lensLast","do","dec","lensIndex","onEmpty","onSlave","over","tranducer","transduce","intoAtomics","tr","intoPipes","hList","pipeSymbols","both","checkReplace","replacers","add","subtract","replacer","doCheckReplace","checker","reducer","doReplaceAll","rules","replAll","lexemize","detectAtomic","detectExpr","detecting","lexemizing","getSyntaxTree","require$$5","require$$4","tool","optimise","exprToPipe","singlePipeToAtomic","Stack","appendTo","pushLast","result","addToLast","convolve","stack","state","states","empty","nextState","stConds","doAction","switches","actions","child","parent","eqOp","stateNames","open","mid","close","next","error","NaN","opCond","opVal","stateConds","CompileException","message","name","collectData","collect","sayPipe","sayAtomic","normalize","say","preproc","getTree","Say","pureExample","simple"],"mappings":"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"}