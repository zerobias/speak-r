{"version":3,"file":null,"sources":["../app/syntax.js","../app/token.js","../app/util.js","../app/fabric.js","../app/lexeme.js","../app/head-list.js","../app/tree.js","../app/splitter.js","../app/string-preprocess.js","../app/convolve.js","../app/print.js","../app/say.js","../app/index.js"],"sourcesContent":["const R = require('ramda')\r\n\r\nconst types = ['type','R','string','number','operator','any','context','lexeme']\r\nconst typesDict = R.pipe(R.map(R.repeat(R.__,2)),R.fromPairs)(types)\r\nconst typeCats = {\r\n  piped:[types.R,types.context,types.lexeme],\r\n  inserted:[types.number,types.string,types.type,types.any],\r\n  control:[types.operator]\r\n}\r\n\r\nconst syntax = {\r\n  pipe:'|>',\r\n  toLast:'<-',\r\n  quotes:['\"',\"'\",'`'],\r\n  operators:['=>','->',',','<~','<-','_','<|>','|>','<|','==','+','-','^','!=','@','::'],\r\n  op:{\r\n    doubledots:'::',\r\n    comma:',',\r\n    dash:'_',\r\n    arrow:'->',\r\n    doublearrow:'=>',\r\n    backpipe:'<|',\r\n    middlepipe:'<|>',\r\n    forwardpipe: '|>',\r\n    equals:'==',\r\n    plus:'+',\r\n    minus:'-',\r\n    map:'^'\r\n  },\r\n  type:{\r\n    list:types,\r\n    dict:typesDict,\r\n    cats:typeCats\r\n  }\r\n}\r\nmodule.exports = syntax","const R = require('ramda')\r\n\r\n/*class Token {\r\n  constructor(type,value) {\r\n    this.type = type\r\n    this.value = value\r\n  }\r\n  // toString(){return `type ${this.type}\\nvalue ${this.value}`+this.index?`${this.index}`:''}\r\n}*/\r\n\r\nconst TokenFabric = R.curry((category,obj)=>{\r\n  return /*new Token(category,obj)*/{\r\n    type:category,\r\n    value:obj\r\n  }\r\n})\r\n\r\nmodule.exports = {\r\n  Type:     TokenFabric('type'),\r\n  R:        TokenFabric('R'),\r\n  String:   TokenFabric('string'),\r\n  Number:   TokenFabric('number'),\r\n  Operator: TokenFabric('operator'),\r\n  Any:      TokenFabric('any'),\r\n  Context:  TokenFabric('context')\r\n}","const R = require('ramda')\r\nconst debug = require('debug')\r\n\r\nconst tagvalue = (tag,mess)=>R.isNil(mess) ? tag : [tag,mess].join(':  ')\r\nconst log = tag=>mess=>debug(tagvalue(tag,mess))\r\nconst pipelog = tag=>mess=>R.tap(log(tag)(mess))\r\n\r\nconst toPipe = R.apply(R.pipe)\r\n\r\nconst pRed = (acc,val)=>R.ifElse(R.is(Array),R.concat(acc),R.append(R.__,acc))(val)\r\nconst P = (...pipes)=>toPipe(R.reduce(pRed,[],pipes))\r\n\r\nconst arrayify = R.unless(R.is(Array),R.of)\r\nconst isContainOrEq = P(arrayify,R.flip(R.contains))\r\n\r\nconst isString = R.is(String)\r\n\r\nconst prop = {\r\n  type:R.prop('type'),\r\n  val:R.prop('value'),\r\n  head:R.prop('head'),\r\n  tail:R.prop('tail')\r\n}\r\nmodule.exports = {\r\n  pipelog,log,isString,arrayify,toPipe,P,isContainOrEq,prop\r\n}","const R = require('ramda')\r\nconst S = require('sanctuary')\r\nconst syntax = require('./syntax.js')\r\n\r\nconst Token = require('./token.js')\r\nconst util = require('./util')\r\nconst isString = util.isString\r\nconst log = util.log('fabric')\r\nconst pipelog = util.pipelog('fabric')\r\n\r\nconst TokenFabric = (tokenType, condition, transformation) => {\r\n  const onCondition = R.pipe(util.arrayify, R.allPass, S.either(R.__, R.F))\r\n  const addSteps = R.flip(R.concat)([tokenType, S.Right])\r\n  const transformUntouched = R.pipe(\r\n    R.defaultTo([]),\r\n    util.arrayify,\r\n    addSteps,\r\n    util.toPipe,\r\n    S.either(R.__, R.identity))\r\n  return R.when(onCondition(condition), transformUntouched(transformation))\r\n}\r\n\r\nconst quoteProcessor = function () {\r\n  const isQuote = R.anyPass(R.map(R.equals, syntax.quotes))\r\n  const isQuoted = R.allPass(R.map(e => R.pipe(e, isQuote), [R.head, R.last]))\r\n  const removeQuotes = R.pipe(R.init, R.tail)\r\n  return TokenFabric(Token.String, [isString, isQuoted], [R.trim, removeQuotes])\r\n}\r\nconst typesProcessor = () => {\r\n  const _types = [\r\n    ['Array', Array],\r\n    ['Number', Number],\r\n    ['String', String],\r\n    ['Function', Function],\r\n    ['Object', Object],\r\n    ['Null', null],\r\n    ['RegExp', RegExp]]\r\n  const types = new Map(_types)\r\n  const isInMap = obj => isString(obj) ? types.has(obj) : false\r\n  return TokenFabric(Token.Type, isInMap, e => types.get(e))\r\n}\r\n\r\nconst isntModifed = R.propOr(true, 'isLeft')\r\nconst isNumber = TokenFabric(Token.Number, isFinite, parseFloat)\r\nconst vendorProcessor = () => {\r\n  const isFunc = R.is(Function)\r\n  const isRamda = obj => isFunc(R[obj])\r\n  return TokenFabric(Token.R, [isString, isRamda], R.prop(R.__, R))\r\n}\r\nconst contextValidation = str => R.pipe(R.match(/\\D\\w+/), R.head, R.equals(str))(str)\r\nconst isContext = TokenFabric(Token.Context, contextValidation)\r\n\r\nconst preprocess = S.lift(R.when(isString, R.trim))\r\nconst postWarn = R.pipe(R.identity, R.assoc('warning', 'left-sided value'))\r\nconst postprocess = R.identity\r\nmodule.exports = {\r\n  isQuote: quoteProcessor(),\r\n  isType: typesProcessor(),\r\n  isVendor: vendorProcessor(),\r\n  isNumber,\r\n  isContext,\r\n  preprocess,\r\n  postprocess\r\n}","const R = require('ramda')\r\n\r\n// const HeadList = require('./head-list.js')\r\n\r\nconst lexemeTypes = {\r\n  pipe:'Pipe',\r\n  context:'Context',\r\n  atomic:'AtomicFunc',\r\n  expr:'Expression'\r\n}\r\n\r\nclass ILexeme {\r\n  constructor(typename,obj) {\r\n    obj.index = obj.head.index\r\n    obj.lexeme = typename\r\n    return obj\r\n  }\r\n}\r\nclass Lexeme {\r\n  static Pipe(tokensHList) {\r\n    return new ILexeme(lexemeTypes.pipe,tokensHList)\r\n  }\r\n  static AtomicFunc(tokensHList) {\r\n    return new ILexeme(lexemeTypes.atomic,tokensHList)\r\n  }\r\n  static Expression(tokensHList) {\r\n    return new ILexeme(lexemeTypes.expr,tokensHList)\r\n  }\r\n  static get its() {\r\n    const eq = R.propEq('lexeme')\r\n    return R.map(eq,lexemeTypes)\r\n  }\r\n  static Context(token) {\r\n    return new Lexeme(lexemeTypes.context,token)\r\n  }\r\n  constructor(typename,obj) {\r\n    console.error('\\n!!!!!!------------Used deprecated Lexeme object!\\n')\r\n    this.lexeme = typename\r\n    this.index = obj.index\r\n    this._value = obj.value\r\n    this.type = 'lexeme'\r\n  }\r\n  get value() {\r\n    console.error('\\n!!!!!!------------Used deprecated get method!\\n')\r\n    return this._value\r\n  }\r\n  set value(val) {\r\n    console.error('\\n!!!!!!------------Used deprecated set method!\\n')\r\n    this._value = val\r\n  }\r\n}\r\n\r\nmodule.exports = Lexeme","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\n\r\nclass HeadList {\r\n  constructor(rawList, head) {\r\n    if (!R.is(Array,rawList)||R.isEmpty(rawList)) return S.Left('No array recieved')\r\n    if (R.isNil(head)) {\r\n      this.head = R.head(rawList)\r\n      this.tail = R.tail(rawList)\r\n    } else {\r\n      this.head = head\r\n      this.tail = rawList||[]\r\n    }\r\n  }\r\n  map(func) {\r\n    return R.map(func,this.toArray)\r\n  }\r\n  get toArray() {\r\n    return R.prepend(this.head,this.tail)\r\n  }\r\n  get length() {\r\n    return R.defaultTo(0,this.tail.length)+R.isEmpty(this.head)?0:1\r\n  }\r\n  append(e) {\r\n    if (R.isEmpty(this.tail)&&R.isEmpty(this.head))\r\n      this.head = e\r\n    else\r\n      this.tail.push(e)\r\n    return this\r\n  }\r\n\r\n  static hasTail(list) {return R.has('tail',list)&&!R.isEmpty(list.tail)}\r\n  static last(list) {\r\n    return HeadList.hasTail(list)\r\n      ? R.last(list.tail)\r\n      : list.head\r\n  }\r\n  static lastR(list,isStrict=false) {\r\n    const _hasTail = R.has('tail')\r\n    const notHas = P(_hasTail,R.not)\r\n    const cond = R.either(notHas,P(HeadList.last,notHas))\r\n    return R.until(isStrict?cond:notHas,HeadList.last)(list)\r\n  }\r\n  static emptyList() {\r\n    return new HeadList([{}])\r\n  }\r\n  static isList(list) {\r\n    return R.has('head',list)\r\n  }\r\n}\r\n\r\nmodule.exports = HeadList","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\n// const log = util.log('tree')\r\n// const pipelog = util.pipelog('tree')\r\nconst prop = util.prop\r\n\r\n// const token = require('./token.js')\r\nconst syntax = require('./syntax.js')\r\nconst Lexeme = require('./lexeme.js')\r\nconst HeadList = require('./head-list.js')\r\n\r\n\r\n\r\n\r\n// const exec = require('./index.js')\r\n\r\nconst op = syntax.op\r\nconst types = syntax.type.dict\r\n// const example = \"tokens :: Array prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n// const exampleNoDef = \"prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n//const onChecking = P(  R.prepend(  R.take(2) , R.equals('|>') ) , R.apply(R.ifElse) )\r\n//const __tranducer = P(R.ifElse(P(R.prop('value'),R.propEq('type','R')),P(R.prop('value'),R.of,R.append)),R.map)\r\n// const exampleTrans = \"ifElse <| prop 'value' propEq 'type' 'R' <|> prop 'value' of append |> map\" // _ identity\r\n\r\nconst propEqVal = R.propEq('value')\r\n\r\nconst isTokenCat = tokenArray=>P(prop.type,util.isContainOrEq(tokenArray))\r\nconst isOperator = isTokenCat(types.operator)\r\n\r\n\r\n// const filterM = func=>e=>e.filter(func)\r\n// const filterMs = func=>P(R.map(filterM(func)),S.justs)\r\n// const indexOf = e => e.isJust ? e.value.index : NaN\r\n// const rangeMs = (min,max)=>R.map(R.reject(e=>indexOf(R.either(R.gt(max),R.lt(min)))))\r\n\r\n//TODO make isSymbol and other work through R.whereEq\r\nconst isSymbol = tokenPred => R.allPass([isOperator, propEqVal(tokenPred)])\r\nconst checkSymbol = R.map(isSymbol,op)\r\n\r\nfunction stringTokenTransform(data) {\r\n  const indexPipe = (e,i)=>S.lift(R.assoc('index',i))(e)\r\n  const indexation = list=>list.map(indexPipe)\r\n  return P(R.map(S.eitherToMaybe),indexation)(data)\r\n}\r\n\r\n// function stageHeader(data) {\r\n//   const errorFabric = text=>()=>S.Left(text)\r\n//   const err = R.map(errorFabric,{\r\n//     nothing:'Nothing finded',\r\n//     many:'Find more than one ::',\r\n//     other:'Undefined error'\r\n//   })\r\n//   const findDD = filterMs(checkSymbol.doubledots)\r\n//   const split = P(R.head,R.prop('index'),R.splitAt(R.__,data),S.Right)\r\n//   const indexChanger = P(R.lensIndex,R.over)\r\n//   const over = {\r\n//     head:indexChanger(0),\r\n//     body:indexChanger(1)\r\n//   }\r\n//   const headChange = P(filterMs(isTokenCat(types.context)),R.map(P(Lexeme.Context,S.Maybe.of)))\r\n//   const headContextMounter = S.either(S.Left,P(over.head(headChange),over.body(R.tail),S.Right))\r\n//   const cond = R.cond([\r\n//     [R.isEmpty,err.nothing],\r\n//     [e=>R.gt(R.length(e),1),err.many],\r\n//     [e=>R.equals(R.length(e),1),split],\r\n//     [R.T,err.other]\r\n//   ])\r\n\r\n//   return P(findDD,cond,headContextMounter)(data)\r\n// }\r\nfunction headSplitter(isMaster,onMaster,changeLast) {\r\n  const lensLast = P(R.length,R.dec,R.lensIndex)\r\n  const onEmpty = e=>R.append(Lexeme.Pipe(new HeadList([e])))\r\n  const onSlave = e=>list=>R.ifElse(R.isEmpty,\r\n    onEmpty(e),\r\n    R.over(lensLast(list),changeLast(e)))(list)\r\n  const tranducer = R.map(R.ifElse(isMaster,onMaster,onSlave))\r\n  return R.transduce(tranducer,(acc,val)=>val(acc))\r\n}\r\nfunction intoAtomics(data) {\r\n  const changeLast = e=>P(util.arrayify,R.append(e.value))\r\n  const isMaster = P(prop.val,isTokenCat([types.R,types.operator,types.context]))\r\n  const onMaster = P(prop.val,R.of,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\nfunction intoPipes(data) {\r\n  const changeLast = e=>hList=>hList.append(e)\r\n  const pipeSymbols = R.anyPass([\r\n    checkSymbol.forwardpipe,\r\n    checkSymbol.middlepipe,\r\n    checkSymbol.backpipe])\r\n  const isMaster = R.both(HeadList.isList,P(prop.head, pipeSymbols))\r\n  const onMaster = P(R.identity,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\n\r\nfunction checkReplace(data) {\r\n  const replacers = [\r\n    [checkSymbol.dash,types.any,R.__],\r\n    [checkSymbol.equals,types.R,R.equals],\r\n    [checkSymbol.plus,types.R,R.add],\r\n    [checkSymbol.minus,types.R,R.subtract],\r\n    [checkSymbol.map,types.R,R.map]\r\n  ]\r\n\r\n  const replacer = (type,value)=>e=>{\r\n    e.value = value\r\n    e.type = type\r\n    return e\r\n  }\r\n  const doCheckReplace = (checker,type,value)=>R.map(R.when(checker,replacer(type,value)))\r\n  const reducer = (acc,val)=>R.apply(doCheckReplace,val)(acc)\r\n  const doReplaceAll = rules=>data=>R.reduce(reducer,data,rules)\r\n  const replAll = doReplaceAll(replacers)\r\n  return replAll(data)\r\n}\r\n\r\nfunction lexemize(data) {\r\n  const detectAtomic = R.when(P(prop.head,isTokenCat(types.R)),Lexeme.AtomicFunc)\r\n  const detectExpr   = R.when(P(prop.head,isTokenCat(types.operator)),Lexeme.Expression)\r\n  // const piping = R.unless(R.has('lexeme'),Lexeme.Pipe)\r\n  const detecting = P(e=>new HeadList(e),detectAtomic,detectExpr)\r\n  const lexemizing = P(S.lift(checkReplace),intoAtomics,R.map(detecting))\r\n  return lexemizing(data)\r\n}\r\n\r\nfunction getSyntaxTree(data) {\r\n  return P(stringTokenTransform,lexemize,intoPipes)(data)\r\n}\r\n\r\n\r\n// let noDefData = stringTokenTransform(exampleNoDef)\r\n\r\n// let atomicList = lexemize(justData)\r\n// let pipedList = intoPipes(atomicList)\r\n// let convolved = convolve(pipedList)\r\n\r\n\r\n// Print.arr('toPrint',R.map(Print.to(Print.pair))(justData))\r\n\r\n// Print.arr('filtered',filterMs(isTokenCat(syntax.type.cats.control))(justData))\r\n\r\n// atomicList.forEach((e,i)=>Print.headList('atomic',e,i))\r\n// pipedList.forEach((e,i)=>Print.headList('piped',e,i))\r\n\r\n\r\n\r\nmodule.exports = getSyntaxTree","const R = require('ramda')\r\nconst util = require('./util')\r\n// const S = require('sanctuary')\r\n\r\nconst Token = require('./token.js')\r\nconst log = util.pipelog('splitter')\r\nconst operators = require('./syntax.js').operators\r\n\r\nconst toPipe = util.toPipe\r\nconst stringMorpher = morph=>R.map(R.when(util.isString,morph))\r\nconst stringTrim = stringMorpher(R.trim)\r\nconst rejectEmpty = R.reject(R.isEmpty)\r\n\r\nconst opersFuncs = [\r\n  R.split,\r\n  R.pipe(Token.Operator,R.intersperse)\r\n]\r\nconst constFuncs = [\r\n  rejectEmpty,\r\n  R.unnest\r\n]\r\n\r\nconst splitCond = symb=>R.cond([\r\n  [R.is(String),symb],\r\n  [R.T,log('uncaught')]\r\n])\r\nconst unnester = symbPipe=>R.pipe(\r\n  symbPipe,\r\n  R.unnest)\r\nconst splitsPipe = [\r\n  R.of,\r\n  R.ap(opersFuncs),\r\n  R.concat(R.__,constFuncs),\r\n  toPipe,\r\n  splitCond,\r\n  R.map,\r\n  unnester,\r\n  log('splitPipe')]\r\nconst splitter = R.pipe(toPipe,R.map(R.__,operators),toPipe)(splitsPipe)\r\nconst cleaner = R.pipe(R.unnest,stringTrim,rejectEmpty,log('end'))\r\nconst execFuncs = [\r\n  util.arrayify,\r\n  splitter,\r\n  cleaner]\r\nconst exec = toPipe(execFuncs)\r\nmodule.exports = {exec,cleaner}","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst fab = require('./fabric.js')\r\n\r\nconst syntax = require('./syntax.js')\r\nconst tree = require('./tree.js')\r\nconst splitter = require('./splitter.js')\r\n\r\nconst util = require('./util')\r\n\r\nconst log = util.log('preproc')\r\nconst pipelog = util.pipelog('preproc')\r\nconst singleWordParsing =\r\n  R.pipe(\r\n    fab.preprocess,\r\n    pipelog('->isQuote'),\r\n    fab.isQuote,\r\n    pipelog('->isNumber'),\r\n    fab.isNumber,\r\n    pipelog('->isType'),\r\n    fab.isType,\r\n    pipelog('->isVendor'),\r\n    fab.isVendor,\r\n    pipelog('->isContext'),\r\n    fab.isContext,\r\n    pipelog('->postprocess'),\r\n    fab.postprocess)\r\nconst splitKeywords=\r\n  R.unary(R.pipe(\r\n    R.unless(util.isString, () => { throw new Error('`keywords` should be String'); }),\r\n\r\n    R.split(' '),\r\n\r\n    R.reject(R.isEmpty),\r\n    splitter.exec,\r\n    R.map(R.ifElse(R.is(Object),S.Right,S.Left)),\r\n    pipelog('тэг'),\r\n\r\n    R.map(singleWordParsing),\r\n    R.dropRepeatsWith((a,b)=>R.allPass([\r\n      R.propEq('type','operator'),\r\n      R.propEq('obj',','),\r\n      R.eqProps('obj',R.__,b)\r\n    ])(a))\r\n  ))\r\n\r\n\r\nmodule.exports = splitKeywords","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\nconst log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\nconst syntax = require('./syntax.js')\r\n\r\nconst types = syntax.type.dict\r\nconst op = syntax.op\r\nconst eq = type=>val=>R.whereEq({type:type,value:val})\r\n\r\nconst eqOp = eq(types.operator)\r\nconst stateNames = ['pipe','open','mid','close']\r\nconst states = {\r\n  empty:0,\r\n  pipe:1,\r\n  open:2,\r\n  mid:3,\r\n  close:4\r\n}\r\nconst actions = {\r\n  next:0,\r\n  child:1,\r\n  parent:-1,\r\n  error:NaN\r\n}\r\nconst opCond = opVal => R.both(Lexeme.its.expr, P(util.prop.head,eqOp(opVal)))\r\nconst stateConds = {\r\n  pipe:Lexeme.its.pipe,\r\n  open:opCond(op.backpipe),\r\n  mid:opCond(op.middlepipe),\r\n  close:opCond(op.forwardpipe)\r\n}\r\n\r\nconst switches = [\r\n  [NaN,1,1,NaN,1], // empty\r\n  [NaN,0,1,NaN,0], // pipe\r\n  [NaN,-1,1,0,-1], // open\r\n  [NaN,-1,1,0,-1], // mid\r\n  [NaN,0,1,NaN,0]  // close\r\n]\r\nfunction optimise(data) {\r\n  const exprToPipe = R.when(Lexeme.its.expr,P(util.prop.tail,e=>new HeadList(e), Lexeme.Pipe))\r\n  const singlePipeToAtomic = R.when(R.both(Lexeme.its.pipe,P(HeadList.hasTail,R.not)),util.prop.head)\r\n  return P(exprToPipe,singlePipeToAtomic)(data)\r\n}\r\nconst appendTo = obj=>e=>obj.append(e)\r\nfunction Stack() {\r\n  this.value = []\r\n  this.push = obj=>this.value.push(appendTo(obj))\r\n  this.pushLast = result=>this.push(HeadList.lastR(result,true))\r\n  this.pop = ()=>this.value.pop()\r\n  this.addToLast = val=>R.last(this.value)(val)\r\n}\r\nfunction convolve(data) {\r\n  if (!R.is(Array,data)) return S.Left('No array recieved')\r\n  var result = HeadList.emptyList()\r\n  let stack = new Stack()\r\n  let state = states.empty\r\n  const stConds = R.append([R.T,states.pipe],R.map(e=>[stateConds[e],()=>states[e]],stateNames))\r\n  let i = 0\r\n  while(i<data.length) {\r\n    var e = data[i]\r\n    let nextState = R.cond(stConds)(e)\r\n    let doAction = switches[state][nextState]\r\n    switch(doAction) {\r\n      case actions.child:\r\n        stack.pushLast(result)\r\n        break\r\n      case actions.parent:\r\n        stack.pop()\r\n        break\r\n    }\r\n    state = nextState\r\n    stack.addToLast(optimise(e))\r\n    i++\r\n  }\r\n  return P(Lexeme.Pipe,optimise)(result)\r\n}\r\n\r\nmodule.exports = convolve","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\nconst log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\n\r\nconst HeadList = require('./head-list.js')\r\n\r\nclass Print {\r\n  static _indexTag(tag) {\r\n    return (e,separ=' ')=>P(util.arrayify,R.prepend(tag),R.join(separ),log)(e)\r\n  }\r\n  static arr(tag,arr){\r\n    let iTag = Print._indexTag(tag)\r\n    return arr.forEach((e,i)=>iTag(i)(e))\r\n  }\r\n  static get funcReplace() {return R.when(P(R.last,R.is(Function)),e=>[e[0],'FUNC'])}\r\n  static get pair(){\r\n    return P(R.toPairs,R.map(Print.funcReplace()))}\r\n  static to(func) {return P(S.maybeToNullable,func)}\r\n  static get typeOrOper() {return R.ifElse(isOperator,prop.val,prop.type)}\r\n  static headList(tag,data,index=0,level=0) {\r\n    const iTag = Print._indexTag(tag)\r\n    const padd = '   '\r\n    const joinPadd = P(R.repeat(padd),R.join(''))\r\n    const objKeys = ['value']\r\n    const keyValPrint = padding=>e=>iTag(['  ',joinPadd(level),padding,e[0]],'')(e[1])\r\n    const tokenPrint = keys=>P(R.props(keys),R.zip(keys),R.forEach(keyValPrint(padd)))\r\n    const isRealIndex = i=>i===-1?'#  ':i+1+((i+1)>=10?' ':'  ')\r\n    const nextLevel = R.add(2,level)\r\n    if (HeadList.isList(data)) {\r\n      keyValPrint(isRealIndex(index))([data.lexeme,data.index])\r\n      Print.headList(tag,data.head,-1,nextLevel)\r\n      if (HeadList.hasTail(data))\r\n        data.tail.forEach((e,i)=>Print.headList(tag,e,i,nextLevel))\r\n    } else {\r\n      keyValPrint(isRealIndex(index))([data.type,data.index])\r\n      tokenPrint(objKeys)(data)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Print","const R = require('ramda')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\nconst util = require('./util')\r\nconst P = util.P\r\n\r\nfunction CompileException(obj) {\r\n  this.message = `Can not compile object ${obj}`\r\n  this.name = \"Compile exeption\"\r\n}\r\n\r\nfunction collectData(obj) {\r\n  const collect = R.cond([\r\n    [R.is(Array),sayPipe],\r\n    [P(HeadList.isList,R.not),util.prop.val],\r\n    [Lexeme.its.pipe,sayPipe],\r\n    [Lexeme.its.atomic,sayAtomic],\r\n    [R.T,e=>{throw new CompileException(e)}]\r\n  ])\r\n  return collect(obj)\r\n}\r\n\r\nfunction sayPipe(list) {\r\n  const normalize = R.when(HeadList.isList,R.prop('toArray'))\r\n  return P(normalize,R.map(collectData),R.apply(R.pipe))(list)\r\n}\r\n\r\nfunction sayAtomic(list) {\r\n  return HeadList.hasTail(list)\r\n    ? R.apply(collectData(list.head),R.map(collectData,list.tail))\r\n    : collectData(list.head)\r\n}\r\n\r\nfunction say(data) {\r\n  return collectData(data)\r\n}\r\n\r\nmodule.exports = say","const R = require('ramda')\r\n// const S = require('sanctuary')\r\n\r\nconst preproc = require('./string-preprocess.js')\r\nconst getTree = require('./tree.js')\r\nconst convolve = require('./convolve.js')\r\n\r\nconst util = require('./util')\r\nconst P = util.P\r\nconst log = util.log('index')\r\n// const pipelog = util.pipelog('index')\r\nconst Print = require('./print.js')\r\nconst Say = require('./say.js')\r\n\r\nfunction say(data) {\r\n  return P(preproc,getTree,convolve,R.tap(e=>Print.headList('conv',e,-1)), Say)(data)\r\n}\r\n\r\nconst pureExample = \"when <| == 1 not <|> + 10 |> + 100\"\r\n// const pure = P( R.when(P(R.equals(1),R.not),R.add(10)),R.add(100))\r\n\r\n// let convolved = say(pureExample)\r\nlog('example')(pureExample)\r\n\r\n// Print.headList('conv',convolved,-1)\r\nlet word = say(pureExample)\r\nlet res = word(1)\r\nlog('word')(res)\r\n\r\nmodule.exports = say"],"names":["const","R","require$$0","types","typesDict","pipe","map","repeat","__","fromPairs","typeCats","piped","context","lexeme","inserted","number","string","type","any","control","operator","syntax","toLast","quotes","operators","op","doubledots","comma","dash","arrow","doublearrow","backpipe","middlepipe","forwardpipe","equals","plus","minus","list","dict","cats","module","exports","TokenFabric","curry","category","obj","value","Type","String","Number","Operator","Any","Context","require$$1","debug","tagvalue","tag","mess","isNil","join","log","pipelog","tap","toPipe","apply","pRed","acc","val","ifElse","is","Array","concat","append","P","reduce","pipes","arrayify","unless","of","isContainOrEq","flip","contains","isString","prop","head","tail","require$$4","S","require$$3","require$$2","Token","util","tokenType","condition","transformation","onCondition","allPass","either","F","addSteps","Right","transformUntouched","defaultTo","identity","when","quoteProcessor","isQuote","anyPass","isQuoted","e","last","removeQuotes","init","trim","typesProcessor","_types","Function","Object","RegExp","Map","isInMap","has","get","isNumber","propOr","isFinite","parseFloat","vendorProcessor","isFunc","isRamda","contextValidation","str","match","isContext","preprocess","lift","postprocess","assoc","isType","isVendor","lexemeTypes","atomic","expr","ILexeme","typename","index","Lexeme","error","_value","Pipe","tokensHList","AtomicFunc","Expression","its","eq","propEq","token","this","HeadList","rawList","isEmpty","Left","func","toArray","prepend","length","push","hasTail","lastR","isStrict","_hasTail","notHas","not","cond","until","emptyList","isList","stringTokenTransform","data","indexPipe","i","indexation","eitherToMaybe","headSplitter","isMaster","onMaster","changeLast","lensLast","dec","lensIndex","onEmpty","onSlave","over","tranducer","transduce","intoAtomics","isTokenCat","tr","intoPipes","hList","pipeSymbols","checkSymbol","both","checkReplace","replacers","add","subtract","replacer","doCheckReplace","checker","reducer","doReplaceAll","rules","replAll","lexemize","detectAtomic","detectExpr","detecting","lexemizing","getSyntaxTree","require$$5","propEqVal","tokenArray","isOperator","isSymbol","tokenPred","stringMorpher","morph","stringTrim","rejectEmpty","reject","opersFuncs","split","intersperse","constFuncs","unnest","splitCond","symb","T","unnester","symbPipe","splitsPipe","ap","splitter","cleaner","execFuncs","exec","require$$6","fab","singleWordParsing","splitKeywords","unary","Error","dropRepeatsWith","a","b","eqProps","optimise","exprToPipe","singlePipeToAtomic","Stack","appendTo","pushLast","result","pop","addToLast","convolve","stack","state","states","empty","stConds","stateConds","stateNames","nextState","doAction","switches","actions","child","parent","whereEq","eqOp","open","mid","close","next","NaN","opCond","opVal","Print","_indexTag","separ","arr","iTag","forEach","funcReplace","pair","toPairs","to","maybeToNullable","typeOrOper","headList","level","padd","joinPadd","objKeys","keyValPrint","padding","tokenPrint","keys","props","zip","isRealIndex","nextLevel","CompileException","message","name","collectData","collect","sayPipe","sayAtomic","normalize","say","preproc","getTree","Say","pureExample","let","word","res"],"mappings":"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"}