{"version":3,"file":null,"sources":["../app/lang/syntax.js","../app/token.js","../app/ramda-piped.js","../app/util.js","../app/fabric.js","../app/splitter.js","../app/string-preprocess.js","../app/lexeme.js","../app/head-list.js","../app/lang/tooling.js","../app/tree.js","../app/convolve.js","../app/say.js","../app/index.js"],"sourcesContent":["const op = {\r\n  doubledots:'::',\r\n  comma:',',\r\n  dash:'_',\r\n  arrow:'->',\r\n  doublearrow:'=>',\r\n  middlepipe:'<|>',\r\n  backpipe:'<|',\r\n  forwardpipe: '|>',\r\n  equals:'==',\r\n  plus:'+',\r\n  minus:'-',\r\n  map:'^'\r\n}\r\nconst types = {\r\n  type:'type',\r\n  R:'R',\r\n  string:'string',\r\n  number:'number',\r\n  op:'operator',\r\n  any:'any',\r\n  context:'context',\r\n  lex:'lexeme'\r\n}\r\nconst jstypes = [\r\n  ['Array', Array],\r\n  ['Number', Number],\r\n  ['String', String],\r\n  ['Function', Function],\r\n  ['Object', Object],\r\n  ['Null', null],\r\n  ['RegExp', RegExp]]\r\nconst quotes = ['\"',\"'\",'`']\r\nconst categories = {\r\n  piped:[types.R,types.context,types.lex],\r\n  inserted:[types.number,types.string,types.type,types.any],\r\n  control:[types.op]\r\n}\r\nconst lexemeTypes = {\r\n  pipe:'Pipe',\r\n  context:'Context',\r\n  atomic:'AtomicFunc',\r\n  expr:'Expression'\r\n}\r\nmodule.exports = {op,types,quotes,categories,jstypes,lexemeTypes}","const R = require('ramda')\r\n\r\n/*class Token {\r\n  constructor(type,value) {\r\n    this.type = type\r\n    this.value = value\r\n  }\r\n  // toString(){return `type ${this.type}\\nvalue ${this.value}`+this.index?`${this.index}`:''}\r\n}*/\r\n\r\nconst TokenFabric = R.curry((category,obj)=>{\r\n  return /*new Token(category,obj)*/{\r\n    type:category,\r\n    value:obj\r\n  }\r\n})\r\n\r\nmodule.exports = {\r\n  Type:     TokenFabric('type'),\r\n  R:        TokenFabric('R'),\r\n  String:   TokenFabric('string'),\r\n  Number:   TokenFabric('number'),\r\n  Operator: TokenFabric('operator'),\r\n  Any:      TokenFabric('any'),\r\n  Context:  TokenFabric('context')\r\n}","const R = require('ramda')\r\n\r\nconst def = (func,obj)=>prop=>\r\n  Object.defineProperty(obj,prop[0],{\r\n    get:function(){\r\n      func(prop[1])\r\n      return obj}})\r\nconst appender = _store=>val=>_store.push(val)\r\nconst inputCheck = (argsArr,_store)=>!R.isEmpty(argsArr)&&!R.is(Function,argsArr[0])&&R.none(R.isNil,argsArr)&&!R.isEmpty(_store)\r\nconst setter = (store,ins,dict)=> R.pipe(R.toPairs,R.forEach(def(appender(store),ins)))(dict)\r\nfunction polymorph(store) {\r\n  return function ins(...val) {\r\n    if (inputCheck(val,store)) {\r\n      store.push(R.apply(store.pop())(val))\r\n    }\r\n    return ins\r\n  }\r\n}\r\nfunction storage(dict) {\r\n  var store = []\r\n  var ins = polymorph(store)\r\n  ins.exec = function() {return R.apply(R.pipe, store)}\r\n  ins.toString = function(){return ''}\r\n  Object.defineProperty(ins,'store',{get:function(){return store}})\r\n  Object.defineProperty(ins,'exec',{get: function() {return R.apply(R.pipe, store)}})\r\n  setter(store,ins,dict)\r\n  return ins\r\n}\r\nconst RP = {}\r\nObject.defineProperty(RP,'do',{get:function(){return storage(R)}})\r\n\r\nmodule.exports = RP","const R = require('ramda')\r\nconst debug = require('debug')\r\n\r\nconst RP = require('./ramda-piped')\r\n\r\nconst tagvalue = (tag,mess)=>R.isNil(mess) ? tag : [tag,mess].join(':  ')\r\nconst log = tag=>mess=>debug(tagvalue(tag,mess))\r\nconst pipelog = tag=>mess=>R.tap(log(tag)(mess))\r\n\r\nconst toPipe = R.apply(R.pipe)\r\n\r\nconst pRed = (acc,val)=>R.ifElse(R.is(Array),R.concat(acc),R.append(R.__,acc))(val)\r\nconst P = (...pipes)=>toPipe(R.reduce(pRed,[],pipes))\r\n\r\nconst arrayify = R.unless(R.is(Array),R.of)\r\nconst isContainOrEq = P(arrayify,R.flip(R.contains))\r\n\r\nconst isString = R.is(String)\r\n\r\nconst prop = {\r\n  type:R.prop('type'),\r\n  val:R.prop('value'),\r\n  head:R.prop('head'),\r\n  tail:R.prop('tail')\r\n}\r\nmodule.exports = {\r\n  pipelog,log,isString,arrayify,toPipe,P,isContainOrEq,prop,RP\r\n}","const R = require('ramda')\r\nconst S = require('sanctuary')\r\nconst syntax = require('./lang/syntax')\r\n\r\n\r\nconst Token = require('./token.js')\r\nconst util = require('./util')\r\nconst isString = util.isString\r\n// const log = util.log('fabric')\r\n// const pipelog = util.pipelog('fabric')\r\n\r\nconst TokenFabric = (tokenType, condition, transformation) => {\r\n  const onCondition = R.pipe(util.arrayify, R.allPass, S.either(R.__, R.F))\r\n  const addSteps = R.flip(R.concat)([tokenType, S.Right])\r\n  const transformUntouched = R.pipe(\r\n    R.defaultTo([]),\r\n    util.arrayify,\r\n    addSteps,\r\n    util.toPipe,\r\n    S.either(R.__, R.identity))\r\n  return R.when(onCondition(condition), transformUntouched(transformation))\r\n}\r\n\r\nconst quoteProcessor = function () {\r\n  const isQuote = R.anyPass(R.map(R.equals, syntax.quotes))\r\n  const isQuoted = R.allPass(R.map(e => R.pipe(e, isQuote), [R.head, R.last]))\r\n  const removeQuotes = R.pipe(R.init, R.tail)\r\n  return TokenFabric(Token.String, [isString, isQuoted], [R.trim, removeQuotes])\r\n}\r\nconst typesProcessor = () => {\r\n  const types = new Map(syntax.jstypes)\r\n  const isInMap = obj => isString(obj) ? types.has(obj) : false\r\n  return TokenFabric(Token.Type, isInMap, e => types.get(e))\r\n}\r\n\r\nconst isNumber = TokenFabric(Token.Number, isFinite, parseFloat)\r\nconst vendorProcessor = () => {\r\n  const isFunc = R.is(Function)\r\n  const isRamda = obj => isFunc(R[obj])\r\n  return TokenFabric(Token.R, [isString, isRamda], R.prop(R.__, R))\r\n}\r\nconst contextValidation = str => R.pipe(R.match(/\\D\\w+/), R.head, R.equals(str))(str)\r\nconst isContext = TokenFabric(Token.Context, contextValidation)\r\n\r\nconst preprocess = S.lift(R.when(isString, R.trim))\r\nconst postprocess = R.identity\r\nmodule.exports = {\r\n  isQuote: quoteProcessor(),\r\n  isType: typesProcessor(),\r\n  isVendor: vendorProcessor(),\r\n  isNumber,\r\n  isContext,\r\n  preprocess,\r\n  postprocess\r\n}","const R = require('ramda')\r\nconst util = require('./util')\r\n// const S = require('sanctuary')\r\n\r\nconst Token = require('./token.js')\r\nconst log = util.pipelog('splitter')\r\nconst operators = R.values(require('./lang/syntax').op) //TODO rewrite op list using\r\n\r\nconst toPipe = util.toPipe\r\nconst stringMorpher = morph=>R.map(R.when(util.isString,morph))\r\nconst stringTrim = stringMorpher(R.trim)\r\nconst rejectEmpty = R.reject(R.isEmpty)\r\n\r\nconst opersFuncs = [\r\n  R.split,\r\n  R.pipe(Token.Operator,R.intersperse)\r\n]\r\nconst constFuncs = [\r\n  rejectEmpty,\r\n  R.unnest\r\n]\r\n\r\nconst splitCond = symb=>R.cond([\r\n  [R.is(String),symb],\r\n  [R.T,log('uncaught')]\r\n])\r\nconst unnester = symbPipe=>R.pipe(\r\n  symbPipe,\r\n  R.unnest)\r\nconst splitsPipe = [\r\n  R.of,\r\n  R.ap(opersFuncs),\r\n  R.concat(R.__,constFuncs),\r\n  toPipe,\r\n  splitCond,\r\n  R.map,\r\n  unnester,\r\n  log('splitPipe')]\r\nconst splitter = R.pipe(toPipe,R.map(R.__,operators),toPipe)(splitsPipe)\r\nconst cleaner = R.pipe(R.unnest,stringTrim,rejectEmpty,log('end'))\r\nconst execFuncs = [\r\n  util.arrayify,\r\n  splitter,\r\n  cleaner]\r\nconst exec = toPipe(execFuncs)\r\nmodule.exports = {exec,cleaner}","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst fab = require('./fabric.js')\r\n\r\nconst splitter = require('./splitter.js')\r\n\r\nconst util = require('./util')\r\n\r\nconst pipelog = util.pipelog('preproc')\r\nconst singleWordParsing =\r\n  R.pipe(\r\n    fab.preprocess,\r\n    pipelog('->isQuote'),\r\n    fab.isQuote,\r\n    pipelog('->isNumber'),\r\n    fab.isNumber,\r\n    pipelog('->isType'),\r\n    fab.isType,\r\n    pipelog('->isVendor'),\r\n    fab.isVendor,\r\n    pipelog('->isContext'),\r\n    fab.isContext,\r\n    pipelog('->postprocess'),\r\n    fab.postprocess)\r\nconst splitKeywords=\r\n  R.unary(R.pipe(\r\n    R.unless(util.isString, () => { throw new Error('`keywords` should be String'); }),\r\n\r\n    R.split(' '),\r\n\r\n    R.reject(R.isEmpty),\r\n    splitter.exec,\r\n    R.map(R.ifElse(R.is(Object),S.Right,S.Left)),\r\n    pipelog('тэг'),\r\n\r\n    R.map(singleWordParsing),\r\n    R.dropRepeatsWith((a,b)=>R.allPass([\r\n      R.propEq('type','operator'),\r\n      R.propEq('obj',','),\r\n      R.eqProps('obj',R.__,b)\r\n    ])(a))\r\n  ))\r\n\r\n\r\nmodule.exports = splitKeywords","const R = require('ramda')\r\n\r\nconst lexemeTypes = require('./lang/syntax').lexemeTypes\r\n\r\nclass ILexeme {\r\n  constructor(typename,obj) {\r\n    obj.index = obj.head.index\r\n    obj.lexeme = typename\r\n    return obj\r\n  }\r\n}\r\nclass Lexeme {\r\n  static Pipe(tokensHList) {\r\n    return new ILexeme(lexemeTypes.pipe,tokensHList)\r\n  }\r\n  static AtomicFunc(tokensHList) {\r\n    return new ILexeme(lexemeTypes.atomic,tokensHList)\r\n  }\r\n  static Expression(tokensHList) {\r\n    return new ILexeme(lexemeTypes.expr,tokensHList)\r\n  }\r\n  static get its() {\r\n    const eq = R.propEq('lexeme')\r\n    return R.map(eq,lexemeTypes)\r\n  }\r\n  static Context(token) {\r\n    return new Lexeme(lexemeTypes.context,token)\r\n  }\r\n}\r\n\r\nmodule.exports = Lexeme","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\n\r\nclass HeadList {\r\n  constructor(rawList, head) {\r\n    if (!R.is(Array,rawList)||R.isEmpty(rawList)) return S.Left('No array recieved')\r\n    if (R.isNil(head)) {\r\n      this.head = R.head(rawList)\r\n      this.tail = R.tail(rawList)\r\n    } else {\r\n      this.head = head\r\n      this.tail = rawList||[]\r\n    }\r\n  }\r\n  map(func) {\r\n    return R.map(func,this.toArray)\r\n  }\r\n  get toArray() {\r\n    return R.prepend(this.head,this.tail)\r\n  }\r\n  get length() {\r\n    return R.defaultTo(0,this.tail.length)+R.isEmpty(this.head)?0:1\r\n  }\r\n  append(e) {\r\n    if (R.isEmpty(this.tail)&&R.isEmpty(this.head))\r\n      this.head = e\r\n    else\r\n      this.tail.push(e)\r\n    return this\r\n  }\r\n\r\n  static hasTail(list) {return R.has('tail',list)&&!R.isEmpty(list.tail)}\r\n  static last(list) {\r\n    return HeadList.hasTail(list)\r\n      ? R.last(list.tail)\r\n      : list.head\r\n  }\r\n  static lastR(list,isStrict=false) {\r\n    const _hasTail = R.has('tail')\r\n    const notHas = P(_hasTail,R.not)\r\n    const cond = R.either(notHas,P(HeadList.last,notHas))\r\n    return R.until(isStrict?cond:notHas,HeadList.last)(list)\r\n  }\r\n  static emptyList() {\r\n    return new HeadList([{}])\r\n  }\r\n  static isList(list) {\r\n    return R.has('head',list)\r\n  }\r\n}\r\n\r\nmodule.exports = HeadList","const R = require('ramda')\r\n\r\nconst util = require('../util')\r\nconst P = util.P\r\n\r\nconst syntax = require('./syntax')\r\nconst types = syntax.types\r\nconst op = syntax.op\r\n\r\nconst multiCheck = func=>R.map(e=>P(util.arrayify,P(func,R.map)(e),R.anyPass))\r\n\r\nconst checkToken = type=>val=>R.whereEq({type:type,value:val})\r\nconst checkOper = checkToken(types.op)\r\nconst checkType = R.propEq('type')\r\n\r\nconst def = (func,obj)=>prop=>\r\n  Object.defineProperty(obj,prop[0],{\r\n    get:function(){\r\n      func(prop[1])\r\n      return obj}})\r\nfunction polymorph(store) {\r\n  return function ins(val) {\r\n    return R.ifElse(R.either(R.isNil,()=>R.isEmpty(store)),()=>ins, R.anyPass(store))(val)\r\n  }\r\n}\r\nconst appender = store=>val=>store.push(val)\r\nconst setter = (store,ins,dict)=>P(\r\n  R.toPairs,\r\n  R.forEach(\r\n    def(appender(store),ins)))(dict)\r\nfunction storage(dict) {\r\n  var store = []\r\n  var ins = polymorph(store)\r\n  Object.defineProperty(ins,'store',{get:function(){return store}})\r\n  setter(store,ins,dict)\r\n  return ins\r\n}\r\n\r\nconst eq = {\r\n  op:       R.map( checkOper )(op),\r\n  type:     R.map( checkType )(types),\r\n  typedVal: R.map( checkToken )(types)\r\n}\r\n\r\nconst equals = {}\r\nObject.defineProperty(equals,'op',{get:function(){return storage(eq.op)}})\r\nObject.defineProperty(equals,'type',{get:function(){return storage(eq.type)}})\r\nObject.defineProperty(equals,'typedVal',{get:function(){return storage(eq.typedVal)}})\r\n\r\n\r\n\r\nmodule.exports = {eq,equals}","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\nconst RP = util.RP\r\n// const log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\nconst prop = util.prop\r\n\r\nconst Lexeme = require('./lexeme.js')\r\nconst HeadList = require('./head-list.js')\r\n\r\nconst types = require('./lang/syntax').types\r\nconst tool = require('./lang/tooling')\r\nconst eq = tool.equals\r\n// const example = \"tokens :: Array prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n// const exampleNoDef = \"prop 'type' indexOf _ 'tokens' equals -1 not\"\r\n//const onChecking = P(  R.prepend(  R.take(2) , R.equals('|>') ) , R.apply(R.ifElse) )\r\n//const __tranducer = P(R.ifElse(P(R.prop('value'),R.propEq('type','R')),P(R.prop('value'),R.of,R.append)),R.map)\r\n// const exampleTrans = \"ifElse <| prop 'value' propEq 'type' 'R' <|> prop 'value' of append |> map\" // _ identity\r\n\r\n// const isTokenCat = tokenArray=>P(prop.type,util.isContainOrEq(tokenArray))\r\n\r\n\r\n// const filterM = func=>e=>e.filter(func)\r\n// const filterMs = func=>P(R.map(filterM(func)),S.justs)\r\n// const indexOf = e => e.isJust ? e.value.index : NaN\r\n// const rangeMs = (min,max)=>R.map(R.reject(e=>indexOf(R.either(R.gt(max),R.lt(min)))))\r\n\r\n//TODO make isSymbol and other work through R.whereEq\r\n// const isSymbol = tokenPred => R.allPass([isOperator, propEqVal(tokenPred)])\r\n// const eq.op = R.map(isSymbol,op)\r\n\r\nfunction stringTokenTransform(data) {\r\n  const indexPipe = (e,i)=>S.lift(R.assoc('index',i))(e)\r\n  const indexation = list=>list.map(indexPipe)\r\n  return P(R.map(S.eitherToMaybe),indexation)(data)\r\n}\r\n\r\n// function stageHeader(data) {\r\n//   const errorFabric = text=>()=>S.Left(text)\r\n//   const err = R.map(errorFabric,{\r\n//     nothing:'Nothing finded',\r\n//     many:'Find more than one ::',\r\n//     other:'Undefined error'\r\n//   })\r\n//   const findDD = filterMs(eq.op.doubledots)\r\n//   const split = P(R.head,R.prop('index'),R.splitAt(R.__,data),S.Right)\r\n//   const indexChanger = RP.do.lensIndex.over.exec\r\n//   const over = {\r\n//     head:indexChanger(0),\r\n//     body:indexChanger(1)\r\n//   }\r\n//   const headChange = P(filterMs(isTokenCat(types.context)),R.map(P(Lexeme.Context,S.Maybe.of)))\r\n//   const headContextMounter = S.either(S.Left,P(over.head(headChange),over.body(R.tail),S.Right))\r\n//   const cond = R.cond([\r\n//     [R.isEmpty,err.nothing],\r\n//     [e=>R.gt(R.length(e),1),err.many],\r\n//     [e=>R.equals(R.length(e),1),split],\r\n//     [R.T,err.other]\r\n//   ])\r\n\r\n//   return P(findDD,cond,headContextMounter)(data)\r\n// }\r\nfunction detectContext(data) {\r\n  // const filt = filterMs(eq.op.doubledots())//x=>R.whereEq({value:\"data\"},x))\r\n  // let dd = P(filt,RP.do.head.indexOf(R.__,data).splitAt(R.__,data).adjust(R.tail,1).exec)(data)\r\n  return data\r\n}\r\nfunction headSplitter(isMaster,onMaster,changeLast) {\r\n  const lensLast = RP.do.length.dec.lensIndex.exec\r\n  const onEmpty = e=>R.append(Lexeme.Pipe(new HeadList([e])))\r\n  const onSlave = e=>list=>R.ifElse(R.isEmpty,\r\n    onEmpty(e),\r\n    R.over(lensLast(list),changeLast(e)))(list)\r\n  const tranducer = R.map(R.ifElse(isMaster,onMaster,onSlave))\r\n  return R.transduce(tranducer,(acc,val)=>val(acc))\r\n}\r\nfunction intoAtomics(data) {\r\n  const changeLast = e=>P(util.arrayify,R.append(e.value))\r\n  const isMaster = P(prop.val,eq.type.R.op.context)\r\n  const onMaster = P(prop.val,R.of,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\nfunction intoPipes(data) {\r\n  const changeLast = e=>hList=>hList.append(e)\r\n  const pipeSymbols = eq.op.forwardpipe.middlepipe.backpipe\r\n  const isMaster = R.both(HeadList.isList,P(prop.head, pipeSymbols))\r\n  const onMaster = P(R.identity,R.append)\r\n\r\n  const tr = headSplitter(isMaster,onMaster,changeLast)\r\n  return tr([],data)\r\n}\r\n\r\nfunction checkReplace(data) {\r\n  const replacers = [\r\n    [eq.op.dash,types.any,R.__],\r\n    [eq.op.equals,types.R,R.equals],\r\n    [eq.op.plus,types.R,R.add],\r\n    [eq.op.minus,types.R,R.subtract],\r\n    [eq.op.map,types.R,R.map]\r\n  ]\r\n\r\n  const replacer = (type,value)=>e=>{\r\n    e.value = value\r\n    e.type = type\r\n    return e\r\n  }\r\n  const doCheckReplace = (checker,type,value)=>R.map(R.when(checker,replacer(type,value)))\r\n  const reducer = (acc,val)=>R.apply(doCheckReplace,val)(acc)\r\n  const doReplaceAll = rules=>data=>R.reduce(reducer,data,rules)\r\n  const replAll = doReplaceAll(replacers)\r\n  return replAll(data)\r\n}\r\n\r\nfunction lexemize(data) {\r\n  const detectAtomic = R.when(P(prop.head,eq.type.R),Lexeme.AtomicFunc)\r\n  const detectExpr   = R.when(P(prop.head,eq.type.op),Lexeme.Expression)\r\n  const detecting = P(e=>new HeadList(e),detectAtomic,detectExpr)\r\n  const lexemizing = P(S.lift(checkReplace),intoAtomics,R.map(detecting))\r\n  return lexemizing(data)\r\n}\r\n\r\nfunction getSyntaxTree(data) {\r\n  return P(stringTokenTransform,detectContext,pipelog('lexemize<-'),lexemize,pipelog('intoPipes'),intoPipes)(data)\r\n}\r\n\r\nmodule.exports = getSyntaxTree","const R = require('ramda')\r\nconst S = require('sanctuary')\r\n\r\nconst util = require('./util')\r\n\r\nconst P = util.P\r\nconst log = util.log('tree')\r\nconst pipelog = util.pipelog('tree')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\n\r\nconst tool = require('./lang/tooling')\r\n\r\n\r\nconst eqOp = tool.eq.op\r\nconst stateNames = ['pipe','open','mid','close']\r\nconst states = {\r\n  empty:0,\r\n  pipe:1,\r\n  open:2,\r\n  mid:3,\r\n  close:4\r\n}\r\nconst actions = {\r\n  next:0,\r\n  child:1,\r\n  parent:-1,\r\n  error:NaN\r\n}\r\nconst opCond = opVal => R.both(Lexeme.its.expr, P(util.prop.head,opVal))\r\nconst stateConds = {\r\n  pipe:Lexeme.its.pipe,\r\n  open:opCond(eqOp.backpipe),\r\n  mid:opCond(eqOp.middlepipe),\r\n  close:opCond(eqOp.forwardpipe)\r\n}\r\nconst stConds = R.cond(R.append([R.T,states.pipe],R.map(e=>[stateConds[e],()=>states[e]],stateNames)))\r\n\r\nconst switches = [\r\n  [NaN,1,1,NaN,1], // empty\r\n  [NaN,0,1,NaN,0], // pipe\r\n  [NaN,-1,1,0,-1], // open\r\n  [NaN,-1,1,0,-1], // mid\r\n  [NaN,0,1,NaN,0]  // close\r\n]\r\nfunction optimise(data) {\r\n  const exprToPipe = R.when(Lexeme.its.expr,P(util.prop.tail,e=>new HeadList(e), Lexeme.Pipe))\r\n  const singlePipeToAtomic = R.when(R.both(Lexeme.its.pipe,P(HeadList.hasTail,R.not)),util.prop.head)\r\n  return P(exprToPipe,singlePipeToAtomic)(data)\r\n}\r\nconst appendTo = obj=>e=>obj.append(e)\r\nfunction Stack() {\r\n  this.value = []\r\n  this.push = obj=>this.value.push(appendTo(obj))\r\n  this.pushLast = result=>this.push(HeadList.lastR(result,true))\r\n  this.pop = ()=>this.value.pop()\r\n  this.addToLast = val=>R.last(this.value)(val)\r\n}\r\nfunction convolve(data) {\r\n  if (!R.is(Array,data)) return S.Left('No array recieved')\r\n  var result = HeadList.emptyList()\r\n  let stack = new Stack()\r\n  let state = states.empty\r\n  let i = 0\r\n  while(i<data.length) {\r\n    var e = data[i]\r\n    let nextState = stConds(e)\r\n    let doAction = switches[state][nextState]\r\n    switch(doAction) {\r\n      case actions.child:\r\n        stack.pushLast(result)\r\n        break\r\n      case actions.parent:\r\n        stack.pop()\r\n        break\r\n    }\r\n    state = nextState\r\n    stack.addToLast(optimise(e))\r\n    i++\r\n  }\r\n  return P(Lexeme.Pipe,optimise)(result)\r\n}\r\n\r\nmodule.exports = convolve","const R = require('ramda')\r\n\r\nconst HeadList = require('./head-list.js')\r\nconst Lexeme = require('./lexeme.js')\r\nconst util = require('./util')\r\nconst P = util.P\r\n\r\nfunction CompileException(obj) {\r\n  this.message = `Can not compile object ${obj}`\r\n  this.name = \"Compile exeption\"\r\n}\r\n\r\nfunction collectData(obj) {\r\n  const collect = R.cond([\r\n    [R.is(Array),sayPipe],\r\n    [P(HeadList.isList,R.not),util.prop.val],\r\n    [Lexeme.its.pipe,sayPipe],\r\n    [Lexeme.its.atomic,sayAtomic],\r\n    [R.T,e=>{throw new CompileException(e)}]\r\n  ])\r\n  return collect(obj)\r\n}\r\n\r\nfunction sayPipe(list) {\r\n  const normalize = R.when(HeadList.isList,R.prop('toArray'))\r\n  return P(normalize,R.map(collectData),R.apply(R.pipe))(list)\r\n}\r\n\r\nfunction sayAtomic(list) {\r\n  return HeadList.hasTail(list)\r\n    ? R.apply(collectData(list.head),R.map(collectData,list.tail))\r\n    : collectData(list.head)\r\n}\r\n\r\nfunction say(data) {\r\n  return collectData(data)\r\n}\r\n\r\nmodule.exports = say","// const R = require('ramda')\r\n// const S = require('sanctuary')\r\n\r\nconst preproc = require('./string-preprocess')\r\nconst getTree = require('./tree')\r\nconst convolve = require('./convolve')\r\n\r\nconst util = require('./util')\r\nconst P = util.P\r\nconst log = util.log('index')\r\n// const pipelog = util.pipelog('index')\r\n// const Print = require('./print.js')\r\nconst Say = require('./say.js')\r\n\r\nfunction say(data) {\r\n  return P(preproc,getTree,convolve,/*R.tap(e=>Print.headList('conv',e,-1)),*/ Say)(data)\r\n}\r\n\r\nconst pureExample = \"data sright :: head prop 'index' splitAt _ @data sright\"\r\nconst simple = \"when <| == 1 not <|> + 10 |> + 100\"\r\n// const pure = P( R.when(P(R.equals(1),R.not),R.add(10)),R.add(100))\r\n\r\n// let convolved = say(pureExample)\r\nlog('example')(pureExample)\r\n\r\n// Print.headList('conv',convolved,-1)\r\nlet word = say(simple)\r\n// let res = word(1)\r\n// log('word')(res)\r\n\r\nmodule.exports = say"],"names":["const","op","doubledots","comma","dash","arrow","doublearrow","middlepipe","backpipe","forwardpipe","equals","plus","minus","map","types","type","R","string","number","any","context","lex","jstypes","Array","Number","String","Function","Object","RegExp","quotes","categories","piped","inserted","control","lexemeTypes","pipe","atomic","expr","module","exports","require$$0","TokenFabric","curry","category","obj","value","Type","Operator","Any","Context","polymorph","store","ins","inputCheck","val","push","apply","pop","storage","dict","exec","toString","defineProperty","get","setter","def","func","prop","appender","_store","argsArr","isEmpty","is","none","isNil","toPairs","forEach","RP","require$$2","debug","require$$1","tagvalue","tag","mess","join","log","pipelog","tap","toPipe","pRed","acc","ifElse","concat","append","__","P","reduce","pipes","arrayify","unless","of","isContainOrEq","flip","contains","isString","head","tail","require$$4","S","require$$3","syntax","Token","util","tokenType","condition","transformation","onCondition","allPass","either","F","addSteps","Right","transformUntouched","defaultTo","identity","when","quoteProcessor","isQuote","anyPass","isQuoted","e","last","removeQuotes","init","trim","typesProcessor","Map","isInMap","has","isNumber","isFinite","parseFloat","vendorProcessor","isFunc","isRamda","contextValidation","str","match","isContext","preprocess","lift","postprocess","isType","isVendor","operators","values","stringMorpher","morph","stringTrim","rejectEmpty","reject","opersFuncs","split","intersperse","constFuncs","unnest","splitCond","symb","cond","T","unnester","symbPipe","splitsPipe","ap","splitter","cleaner","execFuncs","fab","singleWordParsing","splitKeywords","unary","Error","Left","dropRepeatsWith","a","b","propEq","eqProps","ILexeme","typename","index","lexeme","Lexeme","Pipe","tokensHList","AtomicFunc","Expression","its","eq","token","HeadList","rawList","this","toArray","prepend","length","hasTail","list","lastR","isStrict","_hasTail","notHas","not","until","emptyList","isList","checkToken","whereEq","checkOper","checkType","typedVal","stringTokenTransform","data","indexPipe","i","assoc","indexation","eitherToMaybe","detectContext","headSplitter","isMaster","onMaster","changeLast","lensLast","do","dec","lensIndex","onEmpty","onSlave","over","tranducer","transduce","intoAtomics","tr","intoPipes","hList","pipeSymbols","both","checkReplace","replacers","add","subtract","replacer","doCheckReplace","checker","reducer","doReplaceAll","rules","replAll","lexemize","detectAtomic","detectExpr","detecting","lexemizing","getSyntaxTree","require$$6","require$$5","tool","optimise","exprToPipe","singlePipeToAtomic","Stack","appendTo","pushLast","result","addToLast","convolve","stack","state","states","empty","nextState","stConds","doAction","switches","actions","child","parent","eqOp","stateNames","open","mid","close","next","error","NaN","opCond","opVal","stateConds","CompileException","message","name","collectData","collect","sayPipe","sayAtomic","normalize","say","preproc","getTree","Say","pureExample","simple"],"mappings":"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"}